/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package TD2;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import TD2.Paire;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }
    //Exercice 1
    //Question 1

    public void question1() {
        //somme 2 entiers
        Somme<Integer> sommeInteger = (x, y) -> x + y;
        System.out.println(sommeInteger.somme(1, 2));

        //Somme 2 doubles
        Somme<Double> sommeDouble = (x, y) -> x + y;
        System.out.println(sommeDouble.somme(1.0, 2.0));

        //Somme 2 longs
        Somme<Long> sommeLong = (x, y) -> x + y;
        System.out.println(sommeLong.somme(1L, 2L));

        //somme 2 strings
        Somme<String> sommeString = (x, y) -> x + y;
        System.out.println(sommeString.somme("1", "2"));
    }

    //Question 2
    public void question2() {
        final List<String> list1 = List.of("Peanut", "Butter","Nutella");
        final Map<String, Integer> map1 = Map.of("Carotte", 5, "Peche", 12, "Pomme", 7);
        ToString<List<String>> l2s = l -> {
            StringBuffer rtr = new StringBuffer();
            boolean premier = true;
            for (String e : l) {
                if (!premier)
                    rtr.append(", ");
                else
                    premier = false;
                rtr.append(e);
            }
            return rtr.toString();
        };

        ToString<Map<String, Integer>> m2s = m -> {
            final StringBuffer rtr = new StringBuffer();
            boolean premier = true;
            for (final Map.Entry<String, Integer> e : m.entrySet()) {
                if (!premier)
                    rtr.append(", ");
                else
                    premier = false;
                rtr.append(String.format("%s: %d", e.getKey(), e.getValue()));
            }
            return rtr.toString();
        };

        System.out.println(l2s.convert(list1));
        System.out.println(m2s.convert(map1));
    }

    /* Question 3
    Le modele Function prend un argument de type T (générique) puis retourne une valeur.
    Elle convertit un type vers un autre type.

    Le modele Predicate prend un argument de type T (générique) puis retourne une valeur de type boolean.
    Selon un critère, elle teste l'argument puis renvoie si c'estvrai ou faux.

    Le modele Consumer prend un argument de type (générique) mais ne retourne pas de valeur.
    Il accecpte une entrée sans rien retourner.

    Le modele Supplier ne prend pas d'argument mais retourne une valeur de type T (générique).
    Elle génère une sortie.
    */



    //Exercice 2
    public void question1_2() {
        Predicate<Integer> tropPetit = taille -> taille <100;
        Predicate<Integer> tropGrand = taille -> taille >200;
        Predicate<Integer> tailleIncorrecte = tropPetit.or(tropGrand);
        Predicate<Integer> tailleCorrecte = tailleIncorrecte.negate();
        Predicate<Double> tropLourd = poids -> poids > 150.0;
        Predicate<Double> poidCorrecte = tropLourd.negate();
        //acces autorise
        Predicate<Paire<Integer,Double>> accesAutorise = e -> tailleCorrecte.test(e.fst) && poidCorrecte.test(e.snd);



    }

    //Question 2

    public static <T> List<T> filtragePredicatif(List<Predicate<T>> preds, List<T> els) {
        List<T> rtr = new ArrayList<>();
        Predicate<T> pred = x -> true;
        for (Predicate<T> ps :preds ) {
            pred = pred.and(ps);
        }
        for (T e : els) {
            if(pred.test(e)) {
                rtr.add(e);
            }
        }
        return rtr;
    }
         /*

 Notes du prof
            static void foo() {}

         public static <T> List <T> filtragePredicatif (List<T> preds, List<T> els) {
         P<T> global = App.f (ps);
         List <T> rtr = new ArrayList<>();
         for (T e : els){
         if(global.test(e)){
         rtr.add(e);
         }
         }
         return rtr;
         }
/*
         Bifunction<List <P<T>>, List<T>, List<T>> g = (ps,es) -> ....


         ou <T> List <T> g ( List <P<T>> ps, List <T> es) {}
        pg = l -> {}
        function <list<P<T>> avant la fleche, P<T>> apres la fleche

         */


}
